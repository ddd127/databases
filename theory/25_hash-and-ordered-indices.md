## 25. Индексация данных. Упорядоченные и хеш-индексы

Как найти нужную запись в таблице?

- полный просмотр таблицы
- структуры данных

**Полный перебор - не всегда плохо**

Для больщих и средних таблиц - медленно, для маленьких - быстро

Если выбирается большая часть всех данных - быстро, если малая - медленно


**Индекс**

- строится по ключу - набору столбцов (не обязательно уникальному)
- тратят время на построение
- тратят время при обновлении записей
- хранит указатели на записи

### Кластеризованный индекс

Как правило, у таблицы есть "кластеризованный индекс" - 
это порядок, в котором мы упорядочиваем записи в самой таблице.

Такой индекс может быть только один.

### Хеш-индекс

**Что умеет?**

Проверка существования ключа:

- проверка повторений
- in (если известны все составляющие ключа)
- exists
- count

Поиск по ключу:

- natural join


**Как устроен?**

Подсчитали хеши, разбили на корзины, за размер корзины взяли размер страницы.

Считаем, что заголовок хеш-таблицы помещается в память, 
поскольку размер заголовка = количеству страниц = кол-во записей / тысячи

Однако, если корзина превысит размер страницы, будет беда, поэтому

**Расширяемое хеширование**

Заведем сразу кучу корзин, 
будем складывать несколько корзин на одну страницу,
(скорее всего, последовательно), 
при необходимости - разделять.

Тогда пустые или почти пустые корзины почти ничего не занимают, 
а за счет большого их числа уменьшается вероятность коллизий.

Однако, если хеш-функция плохая - очень жаль, это не поможет.

Поэтому будем использовать криптографический хеш, 
который достаточно быстро считается, 
и при этом даже специально перекосить распределение не получится
(если криптография, конечно, ещё работает).

**Побитное расширяемое хеширование**

Можно пойти ещё дальше и сказать, что у нас 2^n корзин,
А локальная глубина страницы - k,
т.е. на этой странице как бы "лежат" 2^(n-k) корзин.

Если понадобилось поделить страницу, поделим её на две,
глубина каждой из которых будет k+1



### Упорядоченный индекс

**Что умеет?**

- проверка существования
- поиск по ключу
- min/max
- диапазон (как загрузка, так и count)
- like по префиксу varchar-а

Также упорядоченный индекс умеет ускорять запросы по префиксу ключа
(например, если индекс на поля (A, B, C), а в запросе только (A, B),
он все еще полезен).


**Как устроен?**

Упорядочиваем ключи по возрастанию, 
ищем в упорядоченной последовательности.

Дерево поиска. Операции работают за O(высота), 
значит, мы хотим минимизировать высоту.

Размер узла положим равным размеру страницы 
и будем максимально ветвиться (для уменьшения глубины).

**B деревья**

От n/2 до n детей
И указатели, и ключи хранятся в узлах.

**B+ деревья**

От n/2 до n детей
Указатели хранятся только в листьях.

n зависит от того, какие у нас данные.
Если там id, то n может быть большим, а если варчары - то маленьким.

Обычно выбираю B+ деревья, 
поскольку за счет меньшего числа данных в узлах 
они сильнее ветвятся. (однако они, на одну страницу глубже).

Корень и несколько первых уровней можно всегда держать в памяти,

В момент, когда высота дерева вырастет, 
его производительность значительно упадет.
(вплоть до 2-х раз). С этим нужно жить.

**Плотность индекса**

Плотный индекс содержит в себе ключи всех элементов

Разреженный - ключи только части элементов.
За счет этого мы ожидаем увеличения степени ветвимости и, 
как следствие, уменьшения высоты.
Также он подходит для кластеризованных данных (напр, все строки с заданным префиксом).
