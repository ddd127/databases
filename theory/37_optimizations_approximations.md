## 37. Оптимизация запросов. Оценка размера и распределения

Мы получили какую-то структуру исполнения запроса 
и нам нужно оценить, за сколько все это будет работать
и какие объемы данных будут на каждом этапе

**Интересующие оценки**

- Получение всех результатов (обычный запрос)
- Время получения первого результата (exist / in)
- Получение только части результатов (offset + limit)

**Размер и распределение**

- **Оценка размера**
    - какой будет результат
    - влезет ли он в память

- **Оценка распределения**
    - какого размера будут соединения


### Статические характеристики

**Характеристики распределения**

- **Основные тенденции**
    - среднее, медиана, мода

- **Распределение**
    - минимум, максимум, дисперсия

- **Размеры**
    - число значений
    - число уникальных

- **Распределение по частотам**
    - типа распределения
    - параметры


**Типы распределений**

- **Распределение отношения**
    - строки
    - страницы

- **Распределение атрибутов**
    - значение
    - размер
    - диапазон
    - распределение (если это, например, числа)

- **Индексы**
    - листы, узлы, высота (реальная / эффективная)
    - уникальные значения, корзины


**Упрощающие предположения**

- Равномерность распределения
- Независимость атрибутов
- Равномерность запросов
- Равномерность заполнения
- Случайность расположения


**Оцениваемые значения**

- Мат ожидание числа чтений страниц
- Мат ожидание количества различных значений

По теореме Христодоулакиса, 
применение всех предположений даст нам оценку для худшего случая

Именно оценка для худшего случая нас и интересует, 
поскольку лучше выполнить запрос за меньшее число ресурсов, 
чем недооценить количество данных и попасть, например, 
на внешнюю сортировку, потому что в память не влезли.

Также не стоит забывать, что если план несколько хуже по времени,
но сильно лучше по памяти, то можно выбрать его -
поскольку параллельно с нами работает ещё несколько транакций 
и место, занятое ими, может сыграть решающую роль.


### Оценка операций

Общий механизм:

Оцениваем либо базовые отношения, либо результаты операций. 
Для базовых отношений у нас есть статистика, 
а для операций у нас есть распределение аргументов и свойства операции.

- **Оценка для таблиц**
    - Индексы
    - Явный пересчет статистики
    - Статистика по исполненным запросам
    - Предположения о распределеии (нормальное / равномерное)


- **Оценка фильтрации**
    - `|Out| = Sel(expression) * |In|`
    - Селективность из распределения
    - Интервальные оценки
    - Сравнение с другим атрибутом
    - `Sel(A & B) = Sel(A) * Sel(B|A)`
    - `Sel(A | B) = Sel(A) + Sel(B) - Sel(A & B)`


- **Оценка соединения**

    Можно сделать хак и сказать, что это фильтр по декаровому произведению

    Если есть какие-то внешние ключи, то можно воспользоваться ими

    - `|Out| = Sel(expression) * |R1| * |R2|`
    - Уникальность ключей `|Out| = min(|R1|, |R2|)`


- **Операции над множествами**

    Сказать что-то более четкое - очень сложно

    - Пересечение `0 <= |Out| = min(|R1|, |R2|)`
    - Объединение `max(|R1|, |R2|) <= |Out| = |R1| + |R2|`
    - Разность `max(|R1| - |R2|, 0) <= |Out| = |R1|`
