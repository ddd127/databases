## 26. Индексация данных. Другие типы индексов. Применение индексов

### Битовый индекс

**Что умеет?**

- логические выражения
- count(*)

Как правило, битовые индексы полностью помещаются в память.


**Как устроен?**

Будем хранить битовые маски по столбцам, 
по одному биту на каждое возможное значение

Однако, обновление работает долго, 
поскольку надо поменять соответствующее значение во всех колонках,
а хранятся они, как правило, в сжатом виде.

Также битовый индекс можно дополнительно сжать 
(хотя это еще больше усложнит перестроение).

- RLE кодирование
- логические операции без распаковки


**Битовый индекс с накоплением**

Для упорядоченных значений.

Можно сделать по разным столбцам.

- запросы на больше-меньше
- запросы на равенство

Пример:

| Id  | Year |  1  |  2  |  3  |  4  |  5  |  6  |
|:---:|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
|  1  |  6   |     |     |     |     |     |  1  |
|  2  |  2   |     |  1  |     |     |     |     |
|  3  |  3   |     |     |  1  |     |     |     |
|  4  |  1   |  1  |     |     |     |     |     |

| Id  | Year |  1  |  2  |  3  |  4  |  5  |  6  |
|:---:|:----:|:---:|:---:|:---:|:---:|:---:|:---:|
|  1  |  6   |     |     |     |     |     |  1  |
|  2  |  2   |     |  1  |  1  |  1  |  1  |  1  |
|  3  |  3   |     |     |  1  |  1  |  1  |  1  |
|  4  |  1   |  1  |  1  |  1  |  1  |  1  |  1  |


### Составные индексы, R-деревья

В каком-то смысле B-деревья на стероидах

**Что умеет?**

Позволяют делать запрос на произвольный поднабор полей ключа индекса


**Как работает?**

Представляем каждый столбец как координату, 
строим на них многомерное дерево.

Настоятельно не рекомендуется реализовывать самому, 
но если в бд-шке есть, то можно.




### Использование индексов

**Когда индекс полезен?**

Когда в запросе есть необходимые поля 
и условие запроса подходит для этого индекса.

**Селективность индекса**

Для каждого индекса нужно понимать, насколько хорошо он распределяет данные, 
какой процент записей мы получим по значению.

Примеры:
- номер паспорта - высокая селективность
- возвраст - средняя селективность
- пол - низкая селективность

При низкой селективности использование индекса бессмысленно.


**Покрывающий индекс**

Если в упорядоченном индексе есть все запрошенные столбцы, 
то запись можно вообще не загружать.

С одной стороны это дублирование данных, а с другой - хорошая оптимизация.

Особенно полезно для join table из пары id, например.


**Какие индексы стоит делать?**

- на ключи (скорее всего, бд сама)
- на внешние ключи
- для таблиц-связей (мб покрывающий)
- для запросов с диапазонами
- для запросов по строкам
