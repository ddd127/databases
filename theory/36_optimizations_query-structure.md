## 36. Оптимизация запросов. Выбор методов исполнения запроса

### Планирование операций

- **Унарные**
    - Фильтрация - первый приоритет
    - Проекция - второй


- **Над множествами**
    - Обычно особо не оптимизируют, потому что их немного
    - Выбираем наиболее подходящий и всё


- **Соединения**
    - Порядок важен (размер промежуточных результатов бывает разным)
    - Боремся за сокращение результатов
    - Много вариантов попереставлять соединения `n! * CatalanNumber(n)`
    - Оценка тоже стоит времени, перебрать слишком много не можем

Поиск оптимального плана тоже занимает время, 
поэтому существуют различные эвристики, 
когда стоит перестать оптимизировать 
и начать наконец что-то делать.


**Оптимизация соединений**

- Совершаем только явно запрошенные соединения, не придумываем новых
- Правый вход - таблица, не надо ветвить соединения (избавились от числа Каталана)

**Динамика на подмножествах**

Оптимизируемая функция:
(множество соединений, виды упорядочивания) => трудозатраты

- **База**
    - Полный просмотр
    - Кластеризованный индекс
    - Поиск по индексу

- **Шаг**
    - Добавляем ко множеству все возможные отношения
    - Перебираем все методы реализации
    - Сохраняем лучшие

В большинстве случаев `O(2^n)`


**Другие подходы**

- Итеративное улучшение со случайным началом
- Эмуляция отжига
- Двухфазная оптимизация (из 2-х предыдущих)
- Генетические алгоритмы


**Точные алгоритмы**

Интересные алгоритмы, но в реальной жизни особо не используются
по причине сложности и ограниченной применимости

- **Алгоритм Ибараки-Камеда**
    - Только для вложенного перебора (а он и так очень грустный)
    - O(n^2 * log n)


- **Алгоритм KBZ**
    - Зависит от формулы трудозатрат
    - Работает для поиск по хешу
    - O(n^2), но реализовать сложно


- **Алгоритм AB**
    - Смягчает ограничения на вид формулы
    - Построен на KBZ
